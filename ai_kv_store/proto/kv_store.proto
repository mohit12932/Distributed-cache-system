// ai_kv_store/proto/kv_store.proto
// ─────────────────────────────────────────────────────────────────────
// Protobuf + gRPC service definitions for the AI-Adaptive KV Store.
// Covers: KV operations, Raft consensus, shard migration, telemetry.
// ─────────────────────────────────────────────────────────────────────

syntax = "proto3";

package ai_kv;

option cc_enable_arenas = true;

// ═══════════════════════════════════════════════════════════════════
//  Core Data Types
// ═══════════════════════════════════════════════════════════════════

message KVPair {
  bytes  key       = 1;
  bytes  value     = 2;
  uint64 timestamp = 3;  // Hybrid logical clock
  bool   tombstone = 4;  // True = delete marker
}

message KeyRange {
  bytes  start_key    = 1;  // Inclusive
  bytes  end_key      = 2;  // Exclusive
  uint32 shard_id     = 3;
}

// ═══════════════════════════════════════════════════════════════════
//  Client KV Service
// ═══════════════════════════════════════════════════════════════════

message GetRequest {
  bytes key              = 1;
  bool  linearizable     = 2;  // If true, goes through Raft leader
}

message GetResponse {
  bool   found           = 1;
  bytes  value           = 2;
  uint64 timestamp       = 3;
  string redirect_leader = 4;  // Non-empty if this node isn't leader
}

message PutRequest {
  bytes  key             = 1;
  bytes  value           = 2;
  uint64 client_seq      = 3;  // Idempotency token
}

message PutResponse {
  bool   success         = 1;
  uint64 committed_index = 2;
  string redirect_leader = 3;
}

message DeleteRequest {
  bytes  key             = 1;
  uint64 client_seq      = 2;
}

message DeleteResponse {
  bool   success         = 1;
  uint64 committed_index = 2;
  string redirect_leader = 3;
}

message ScanRequest {
  bytes  start_key       = 1;
  bytes  end_key         = 2;
  uint32 limit           = 3;
}

message ScanResponse {
  repeated KVPair pairs  = 1;
  bool   has_more        = 2;
}

service KVStoreService {
  rpc Get    (GetRequest)    returns (GetResponse);
  rpc Put    (PutRequest)    returns (PutResponse);
  rpc Delete (DeleteRequest) returns (DeleteResponse);
  rpc Scan   (ScanRequest)   returns (ScanResponse);
}

// ═══════════════════════════════════════════════════════════════════
//  Raft Consensus Service
// ═══════════════════════════════════════════════════════════════════

enum LogEntryType {
  LOG_ENTRY_NORMAL     = 0;  // Client command (put/delete)
  LOG_ENTRY_CONFIG     = 1;  // Cluster membership change
  LOG_ENTRY_SHARD_MOVE = 2;  // Shard migration command
  LOG_ENTRY_NOOP       = 3;  // Leader's first entry after election
}

message LogEntry {
  uint64       term    = 1;
  uint64       index   = 2;
  LogEntryType type    = 3;
  bytes        command = 4;  // Serialized KVPair or ShardMoveCmd
}

// — AppendEntries (heartbeat + log replication) —

message AppendEntriesRequest {
  uint64 term           = 1;  // Leader's term
  uint32 leader_id      = 2;
  uint64 prev_log_index = 3;  // Index of entry preceding new ones
  uint64 prev_log_term  = 4;  // Term of prev_log_index entry
  repeated LogEntry entries = 5;
  uint64 leader_commit  = 6;  // Leader's commit index
}

message AppendEntriesResponse {
  uint64 term           = 1;  // Follower's current term
  bool   success        = 2;
  uint64 match_index    = 3;  // Highest index replicated
  // Optimization: on rejection, hint where to retry
  uint64 conflict_index = 4;
  uint64 conflict_term  = 5;
}

// — RequestVote (leader election) —

message RequestVoteRequest {
  uint64 term           = 1;
  uint32 candidate_id   = 2;
  uint64 last_log_index = 3;
  uint64 last_log_term  = 4;
}

message RequestVoteResponse {
  uint64 term           = 1;
  bool   vote_granted   = 2;
}

// — Heartbeat (lightweight keep-alive, separate from AppendEntries for perf) —

message HeartbeatRequest {
  uint64 term           = 1;
  uint32 leader_id      = 2;
  uint64 leader_commit  = 3;
}

message HeartbeatResponse {
  uint64 term           = 1;
  bool   success        = 2;
}

// — InstallSnapshot (for far-behind followers) —

message InstallSnapshotRequest {
  uint64 term               = 1;
  uint32 leader_id          = 2;
  uint64 last_included_index = 3;
  uint64 last_included_term = 4;
  uint64 offset             = 5;
  bytes  data               = 6;
  bool   done               = 7;
}

message InstallSnapshotResponse {
  uint64 term               = 1;
}

service RaftService {
  rpc AppendEntries   (AppendEntriesRequest)   returns (AppendEntriesResponse);
  rpc RequestVote     (RequestVoteRequest)     returns (RequestVoteResponse);
  rpc Heartbeat       (HeartbeatRequest)       returns (HeartbeatResponse);
  rpc InstallSnapshot (stream InstallSnapshotRequest) returns (InstallSnapshotResponse);
}

// ═══════════════════════════════════════════════════════════════════
//  Shard Migration Service
// ═══════════════════════════════════════════════════════════════════

message ShardMigrationRequest {
  uint32   source_shard     = 1;
  uint32   target_shard     = 2;
  KeyRange key_range        = 3;
  double   predicted_heat   = 4;  // PINN output that triggered migration
  uint64   migration_id     = 5;  // Unique ID for idempotency
}

message ShardMigrationResponse {
  bool   accepted           = 1;
  uint64 migration_id       = 2;
  string error              = 3;
}

message MigrationDataChunk {
  uint64          migration_id = 1;
  repeated KVPair pairs        = 2;
  bool            is_last      = 3;
  uint64          checksum     = 4;  // CRC32 of this chunk
}

message MigrationAck {
  uint64 migration_id       = 1;
  uint64 pairs_received     = 2;
  bool   complete           = 3;
}

service ShardMigrationService {
  // Initiate a migration (goes through Raft for consensus)
  rpc RequestMigration (ShardMigrationRequest) returns (ShardMigrationResponse);

  // Stream key-value pairs from source to target
  rpc TransferData (stream MigrationDataChunk) returns (MigrationAck);
}

// ═══════════════════════════════════════════════════════════════════
//  Telemetry Service (for PINN training data)
// ═══════════════════════════════════════════════════════════════════

message ShardTelemetry {
  uint32 shard_id        = 1;
  double qps             = 2;  // Queries per second
  double p99_latency_us  = 3;  // Microseconds
  double write_ratio     = 4;  // Fraction of writes vs reads
  uint64 key_count       = 5;
  uint64 byte_size       = 6;
  double timestamp       = 7;  // Unix epoch seconds (double for sub-ms)
}

message TelemetryReport {
  uint32 node_id                   = 1;
  repeated ShardTelemetry shards   = 2;
  double  cpu_usage                = 3;
  double  memory_usage_bytes       = 4;
  double  disk_io_util             = 5;
}

message TelemetryAck {
  bool received = 1;
}

message HeatMapRequest {
  double prediction_horizon_sec    = 1;  // How far ahead to predict
}

message HeatMapResponse {
  repeated ShardHeat shards        = 1;
  double  prediction_timestamp     = 2;
}

message ShardHeat {
  uint32 shard_id                  = 1;
  double predicted_heat            = 2;  // PINN output: u(t+Δt, x)
  double current_heat              = 3;  // Observed current load
  double gradient                  = 4;  // ∂u/∂t — rate of change
}

service TelemetryService {
  rpc ReportTelemetry (TelemetryReport) returns (TelemetryAck);
  rpc GetHeatMap      (HeatMapRequest)  returns (HeatMapResponse);
}
